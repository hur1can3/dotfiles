#!/bin/bash
#
# pbrisbin 2009, 2010
#
# aurget :: A simple pacman-like interface to the AUR
#
# stable        : http://pbrisbin.com:8080/sources/aurget
# bleeding edge : http://pbrisbin.com:8080/bin/aurget
#
# version : 1.4-5
#
# config  : ${XDG_CONFIG_HOME:-$HOME}/aurgetrc
# depends : curl
#
# CHANGELOG {{{
#
# -5: change config file location depending on XDG_CONFIG_HOME
#
# -4: fixed a bug with makepkg in subshell, needed --noconfirm
#
# -3: add a little set_title funct to set the term title, i
#       know bruenig... is bloat.
#
# -2: damn subshells again...
#
# .4: general code cleanup
#
# -9: stupidly re-added the sudo sudo sudo pacman bug
#       from way back when... fixed
#
# -8: had to fix a bug caused by -7 :/
#
# -7: removed stupid subshells and find -execs that
#       were making calls to errorout() get ignored
#       bad bash! no, bad!
#
# -6: alot of little cleanups, mainly just to make
#       it easier on myself to maintain.
#
#     fixed bug created by option parsing in -5
#
# -5: split out parsing of options from main()
#
#     changed behavior b/w buildit and installit
#
#     adjusted help... again
#
#     added better documentation on all functions
#
# -4: adjusted options handling, MODE handling, help
#       and default config. MODEs like info and search
#       WILL BE USED even with active options like -u
#       and -U where it might not make sense
#
# -3: adjusted options handling and help message
#
# -2: change to dep checking to handle provides=()
#       appropriately when seeing if pacman offers
#       a required dep
#
#     added -q and -p options (see --help)
#
#     general code cleanup (a WD with a space it it
#       should even work ok now)
#
# .3: change search to handle multi-words and add -F to
#       all greps that could use it.
#
# -9: changed upgrade() and devel() to not recall aurget
#       but rather call the new main() that does all the
#       work. now -e or -D options are persisted when
#       used with -u or -U. TODO: reevaulate how options
#       are parsed (-D passed /after/ -u is ignored).
#
# -8: place JSON results into arrays rather then parsing
#       each line on each result -- thanks bruenig
#
# -7: install deps --asdeps
#
# -6: stopped using '"' as the delimeter for JSON data;
#       this caused issues when pkg descs had \"s in it
#
# -5: adjusted the wgetting of package source to actually
#       go to the fallback url if the url out of the JSON
#       interface fails; i had done this, but forgot to
#       remove the exit-on-error and it never actually
#       tried to fallback url.
#
# -4: searching was being sorted by ID and not name,
#       now fixed to sort on the name; thanks dalingrin
#
# -3: fixed a nasty bug in dep_check, any deps with
#       versioning were being flat out ignored, rather
#       than stripped of the version as i'd intended
#
#     also, adjusted clean_exit to exit 1 if it's on
#       an unsuccessful search or user-abort
#
# -2: adjusted the PKGBUILD find command to only return
#       one result, some packages contain multiple
#       PKGBUILDS; i don't yet know why, but it breaks
#       this script if multiple are returned. - thanks
#       to Henrique Abreu for this fix
#
# .2: check IGNORES on upgrade before passing targets to
#       install; now you see a warning of the ignore
#       rather than the error of no targets.
#
# -9: added MAKEPKG_OPTS as config option
#
# -8: removed dumb devtools optdep and conditional use of
#       vercmp; vercmp is in fact supplied by pacman
#
# -7: in prompt() A="" should be a positive as implied by
#       [Y/n]... it does this now
#
# -6: adjusted makepkg to deal with possible user-defined
#       PKGDEST variable
#
# -5: narrowed down the find command to only install
#       $PACK-*.pkg.tar.gz. fixes issues with lib32 packages
#       that download 32 bit packages as sources
#
# -4: typo in example config: s/csv/csv
#
# -3: added -v option to show version info
#
# -2: just updated some minor wording related to
#       the config file that's auto-created
#
# .1: if the user has devtools installed, vercmp is
#       used to compare local vs aur version. it's
#       much more accurate
#
# -9: fixed bug in installit where multiple calls                      
#       would lead to PACMAN="sudo sudo ... $PACMAN"
#
# -8: added source_pkgbuild function which makes
#       sourcing a PKGBUILD a bit safer
#
#     merged seach() and info() into isearch()
#
# -7: added DEVELS config option to filter out (or in)
#       development snapshot packages in options like
#       -u and -U
#
#     general code cleanup
#
# -6: added option -I to print extended info for an
#       aur package
#
# -5: aurget now uses a self generating config file
#
# -4: totally changed handling of options, see help,
#       and set the defaults defined in this script.
#
#     other minor formatting and bugfixing
#
# -3: fixed a bug in downloadit()
#
#     if JSON has a bad url, aur/pack/pack.tar.gz is
#       downloaded as a fallback
#
# -2: since deps.lst is parsed backwards, i added a for
#       loop to reverse the arguments so it installs in
#       the order you specify
#
### }}}

#### Info #### {{{
SCRIPT_NAME='Aurget'
SCRIPT_DESCRIPTION='A simple pacman-like interface to the AUR'
SCRIPT_AUTHOR='Patrick Brisbin <pbrisbin@gmail.com>'
SCRIPT_VERSION='1.4-5'
SCRIPT_DATE='2/22/2010'

# }}}

#### Functions #### {{{

# utilities {{{
# set the term titlebar
set_title() { echo -ne "\033]0;$(basename "$0")\007"; }

# notification messages
display() { echo -e "\e${colorB}:: \e${colorW}$1\e[0m"; }

# warning messages
warn() { echo -e "\e${colorY}warning: \e[0m$1"; }

# error messages
errorout() {
  echo -e "\e${colorR}error: \e[0m$2"

  # pass '2' to make user aware of leftover files
  [ $1 -eq 2 ] && echo "Note: source files may still be in $WD"

  exit $1
}

# set up environment
make_clean() {
  # wipe temp dir
  rm -rf "$WD"
  mkdir -p "$WD"

  # create package dir
  [ -d "$PD" ] || mkdir -p "$PD"
}

# cleanup and exit
clean_exit() { 
  rm -rf "$WD"

  # allow custom exit status
  exit "${1:-0}"
}

# prompt user
prompt() {
  echo -n "$1? [Y/n] " && read A

  # y is default
  [ -z "$A" ] && return 0

  case $A in
    y|Y) return 0     ;;
    q|Q) clean_exit 1 ;; # hidden opt
    *)   return 1     ;;
  esac
}

# }}}

# a help message {{{
message() {
  echo "usage: aurget [options] [arguments] ..."
  echo
  echo "  modal options: these override the \$MODE set in your config"
  echo
  echo "        -s, --search     search the aur for [arguments]"
  echo "        -q, --quiet      like search but output only package names"
  echo "        -I, --info       output extended info for [arguments]"
  echo "        -p, --print      print the PKGBUILD for [arguments] on stdout"
  echo
  echo "        -d, --download   download the tarball for [arguments]"
  echo "        -b, --build      download and build [arguments]"
  echo "        -i, --install    download, build, and install [arguments]"
  echo
  echo "  active options: these will respect the value of \$MODE when they operate"
  echo
  echo "        -u, --upgrade    check for available aur upgrades"
  echo "        -U, --devel      process all devel [git, svn, etc] packages"
  echo
  echo "  other options: these are independent of \$MODE"
  echo
  echo "        -e, --edit       prompt to edit all PKGBUILDs"
  echo "        -D, --nodeps     disable all auto dependency resolution"
  echo
  echo "        -v, --version    print version info"
  echo "        -h, --help       display this"
  echo
  echo "  notes:"
  echo
  echo "        default configuration is equivalent to -i -e -D"
  echo
  echo "        using -D means you're not checking any dependencies"
  echo "          i.e. makepkg -d is used"
  echo
  echo "        passing multiple modal options simply override each other"
  echo "          i.e. -speqbeD is equivalent to -e -D -b"
  echo
  echo "        active option -u always overrides active option -U"
  echo "          i.e. -puUbed is equivalent to -e -d -u"
  echo
  exit 1
}

# }}}

# print version info {{{
version_info() {
  echo
  echo "  $SCRIPT_NAME: $SCRIPT_DESCRIPTION"
  echo
  echo "  author:      $SCRIPT_AUTHOR"
  echo "  version:     $SCRIPT_VERSION"
  echo "  last update: $SCRIPT_DATE"
  echo
  exit 0
}

# }}}

# lock file {{{
#
# accepts one arg: set or remove
#
# does whatever needed regarding the
# lock file
#
# *note: this function is not used yet*
#
###
lock_file() {
  local arg="$1" islocked

  # sanity check
  [ -z "$LOCK" ] && errorout 1 'filename for lock not set'

  case $arg in
    set)    [ -f "$LOCK" ] && islocked=1 || islocked=0         ;;
    remove) rm -f "$LOCK" || warn 'could not remove lock file' ;;
    *)      errorout 1 'invalid argument to set_lock function' ;;
  esac

  # set include the check
  if [ $islocked -eq 1 ]; then

    cat << EOF
A lock file has been found at $LOCK. If you are sure
no other aurget processes are running, you can safely
remove this file and try again.
EOF

    clean_exit 1
  else
    touch "$LOCK" || errorout 1 'could not set lock file'
  fi
}

# }}}

# set defaults and create a config file {{{
create_config() {
  local CONFIG

  # change config file location here:
  #local CONFIG="${XDG_CONFIG_HOME:-$HOME}/aurgetrc"

  if [ -n "$XDG_CONFIG_HOME" ]; then
    CONFIG="$XDG_CONFIG_HOME/aurgetrc"
  else
    CONFIG="$HOME/.aurgetrc"
  fi

  if [ ! -f "$CONFIG" ]; then
    echo
    echo ":: Created default config file at $CONFIG;"
    echo ":: be sure to edit this to your liking."
    echo

    cat > "$CONFIG" << EOF
############################################################
#                                                          #
#                   Aurget Config File                     #
#                                                          #
#  Edit this as you like, but keep the bash syntax; it's   #
#  sourced directly from the main script.                  #
#                                                          #
#  Defaults are listed and commented, uncomment to tweak.  #
#                                                          #
#  Remember kids, don't run me as root; instead, have a    #
#  NOPASSWD sudoers line for pacman if you want me to      #
#  install things                                          #
#                                                          #
############################################################

### Working Directory:
#
# This directory is dynamically created AND DESTROYED
# it is a place to do some work and keep transitional
# files.
#
###

#WD="/tmp/aurget"

### Package Directory:
#
# This directory will be created, but never destroyed
# it is the place to put any built packages. This
# happens if you install or build -- your AUR cache
#
###

#PD="\$HOME/Packages"

### Package Manager:
#
# By default, pacman is used, or you can override
# that here. sudo will be added automatically, do not
# add it here.
#
###

#PACMAN="pacman"

### Makepkg Opts:
#
# These flags will be passed directly to makepkg as-is.
#
# Do not put -s, -d, or --noconfirm here as they are
# already added as needed.
#
# ex: MAKEPKG_OPTS="--skipinteg"
#
###

#MAKEPKG_OPTS=""

### Editor:
#
# This will be used to edit PKGBUILDs before sourcing
# or installing (if desired).
#
# By default, your \$EDITOR environment variable is
# used, or you can override it here.
#
###

#EDITOR=""

### Default Behavior:
#
# These are overriden by any commandline options, you 
# should define the default no-options behavior here.
#
# note: MODE is respected even when using -u and -U
# 
# see 'modal options' under --help for more info
#
###

#MODE="install" # choices: info, search, quiet, print, download, build, or install
#DEPS=0         # choices: 1 resolve dependencies (convenient), 0 don't (safe)
#EDIT=1         # choices: 1 prompt to edit PKGBUILDS (safe), 0 don't (convenient)

### Devel:
#
# This regex is used by grep to match development
# packages which are ignored in the -u option and
# utilized in the -U option.
#
###

#DEVELS=".*-git$\|.*-hg$\|.*-svn$\|.*-darcs$\|.*-cvs$"

### Ignores:
#
# A space-separated list of packages to ignore.
#
# ex: IGNORES="package1 package2 package3"
#
###

#IGNORES=""

### Colors:
#
# Defaults to no color, uncomment to enable.
#
###

#colorW="[1;37m" # white
#colorB="[1;34m" # blue
#colorR="[1;31m" # red
#colorG="[1;32m" # green
#colorY="[1;33m" # yellow
#colorM="[1;35m" # magenta

###
EOF

  fi

  # set defaults
  WD='/tmp/aurget'
  PD="$HOME/Packages"

  DEPS=0
  EDIT=1

  MAKEPKG_OPTS=''
  IGNORES=''

  # no color
  colorW='[0m'
  colorB='[0m'
  colorR='[0m'
  colorG='[0m'
  colorY='[0m'
  colorM='[0m'

  # source user config
  . "$CONFIG"

  # MODE needs to be non null no matter what
  # reset default if user made it null
  MODE="${MODE:-install}"

  # DEVELS needs to be non null no matter what
  # reset default if user made it null
  DEVELS="${DEVELS:-.*-git$\|.*-hg$\|.*-svn$\|.*-darcs$\|.*-cvs$}"

  # preemptively remove sudo
  PACMAN="${PACMAN/sudo /}"

  # now check for valid PACMAN and EDITOR
  which $PACMAN &>/dev/null || PACMAN='pacman'
  which $EDITOR &>/dev/null || EDITOR='nano'
}

# }}}

# source PKGBIULD {{{
#
# accepts one arg at a time
#
# puts portion of arg above the build() into
# a temp file and sources it
#
###
source_pkgbuild() {
  # grep expression to see where the build() is
  local build='^build.*{$\|^function build.*{$' 

  # put the top half in a file to be sourced
  grep -B 999 "$build" "$1" | grep -v "$build" > "$WD/sourceme"

  # source and remove
  . "$WD/sourceme" &>/dev/null; rm "$WD/sourceme"
}

# }}}

# print PKGBUILD {{{ 
#
# accepts multiple args
#
# prints each args PKGBUILD on stdout
#
###
printpbuild() {
  ret=0

  for PACK in $@; do
    [ -d "$WD/$PACK" ] || mkdir -p "$WD/$PACK"

    wget -q -O "$WD/$PACK/PKGBUILD" "http://aur.archlinux.org/packages/$PACK/$PACK/PKGBUILD"

    if [ -s "$WD/$PACK/PKGBUILD" ]; then
      cat "$WD/$PACK/PKGBUILD"
    else
      ret=1
    fi
  done

  clean_exit $ret
}

# }}}

# searches AUR {{{
#
# accepts one arg
#
# returns an url-encoded string for passing as
# JSONs search term
#
###
clean_string() {
  local string="$1"

  # need to add more, probably switch to sed
  # as these rack up
  string="${string//%/%25}"
  string="${string//+/%2B}"
  string="${string// /%20}"

  echo "$string"
}

# accepts one arg (no word splitting)
#
# searchs AUR JSON for a search term
#   prints only names if MODE=quiet
#   matches name exactly if MODE=info
#
###
search() {
  touch "$WD/results.lst"
  local term="$*"
  local GREP='ID'

  # package name has to match for info type search
  [ "$MODE" = 'info' ] && GREP="$term"

  curl -s "http://aur.archlinux.org/rpc.php?type=search&arg=$(clean_string "$term")" | sed 's/{/\n/g;s/}//g' | grep -F "\"$GREP\"" | sort -t ':' -k 3.2 >> "$WD/results.lst"

  # no results
  [ ! -s "$WD/results.lst" ] && clean_exit 1

  # thanks to bruenig for this approach
  local IFS=$'\n'
  local names=( $(awk -F '","' '{print $2}'  "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-1)}') ) 
  local verss=( $(awk -F '","' '{print $3}'  "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-1)}') )
  local flags=( $(awk -F '","' '{print $11}' "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-3)}') )
  # add a space on desc incase it's null (else arrays get desynchronized)
  local descs=( $(awk -F '","' '{print $5}'  "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-1) " "}' | sed 's/\\//g') )

  for ((i=0; i<${#names[@]}; i++)); do
    local name="${names[$i]}"

    # quiet
    if [ "$MODE" = 'quiet' ]; then
      echo -e "\e${colorW}$name\e[m"

    # search
    elif [ "$MODE" = 'search' ]; then
      local vers="${verss[$i]}"
      local desc="${descs[$i]}"
      local flag="${flags[$i]}"
      local outofdate="No"

      echo -e -n "\e${colorM}aur/\e${colorW}$name \e${colorG}$vers\e[0m"
      [ "$flag" = "1" -o "$flag" = "OutOfDate" ] && echo -e -n " \e${colorR}[out of date]\e[0m"
      echo -e "\n    $desc"

    # info
    else
      local vers="${verss[$i]}"
      local desc="${descs[$i]}"
      local flag="${flags[$i]}"
      local outofdate="No"

      [ "$flag" = '1' -o "$flag" = 'OutOfDate' ] && outofdate="\e${colorR}Yes\e[0m"

      echo -e "\e${colorW}Repository \t: \e${colorM}aur\e[0m"
      echo -e "\e${colorW}Name \t\t: $name\e[0m\e[0m"
      echo -e "\e${colorW}Version \t: \e${colorG}$vers\e[0m"
      echo -e "\e${colorW}Out of date \t: \e[0m$outofdate"
      echo -e "\e${colorW}Description \t: \e[0m$desc"
      echo
    fi
  done
}

# }}}

# upgrading {{{
#
# accepts no args
#
# finds all devel packages and sends them to
# main or search depending on MODE
#
###
devel() { 
  # reset
  dodevel=0

  display 'Starting AUR development upgrade...'

  args=( $(pacman -Qqm | grep "$DEVELS") )

  # handle search modes differently
  if [ "${#args[@]}" -ne 0 ]; then
    case $MODE in
      search|info|quiet) for term in "${args[@]}"; do search "$term"; done ;;
      *)                 main                                              ;;
    esac
  fi
}

# accepts no args
#
# finds all AUR packages with available upgrades
# and sends them to main or search depending on
# MODE
#
###
upgrade() {
  # reset
  doupgrade=0

  display 'Starting AUR upgrade...'
  args=()

  local LC_ALL="C"
  while read name vers; do
    # skip devel packages entirely
    echo $name | grep -q "$DEVELS" && continue

    # available version 
    versN="$(curl -s "http://aur.archlinux.org/rpc.php?type=search&arg=${name}" | sed 's/{/\n/g' | awk -F '","' "/\"$name\"/"'{print $3}' | awk -F ':' '{print substr($2,2,length($2)-1)}')"

    [ -z "$versN" ] && continue

    # check against ignores
    if echo " $IGNORES " | grep -Fq " $name "; then
      warn "$name: ignoring package upgrade ($vers => $versN)"
      continue
    fi

    # use vercmp always
    check=$(vercmp "$vers" "$versN")
    [ $check -gt 0 ] && warn "$name: local ($vers) is newer than aur ($versN)"
    [ $check -lt 0 ] && args+=( $name )
  done < <(pacman -Qm)

  if [ "${#args[@]}" -ne 0 ]; then
    # handle search modes differently
    case $MODE in
      search|info|quiet) for term in "${args[@]}"; do search "$term"; done ;;
      *)                 main                                              ;;
    esac
  else
    echo ' local database is up to date'
  fi
}
  
# }}} 

# dependency checking {{{
#
# accepts multiple args
#
# creates a list of targets + their deps or
# just a list of targets if DEPS=0
#
###
dep_check() {
  echo 'resolving dependencies...'

  while true; do
    N=$(wc -l < "$WD/deps.lst")

    for name in $(awk '{print $1}' "$WD/deps.lst"); do
      [ -d "$WD/$name" ] && continue
      mkdir "$WD/$name" && wget -q -O "$WD/$name/PKGBUILD" "http://aur.archlinux.org/packages/$name/$name/PKGBUILD"

      if [ $? -ne  0 ]; then
        continue
      else
        # safety first!
        if [ $EDIT -eq 1 ]; then
          $EDITOR "$WD/$name/PKGBUILD"
          prompt 'Source this PKGBUILD for deps' || continue
        fi

        # this will get sourced anyway, but we need it here incase
        # there are $CARCH dependant depends
        [ -z "$CARCH" ] && . /etc/makepkg.conf

        source_pkgbuild "$WD/$name/PKGBUILD"
      fi

      # assumes anything not in repos is available in AUR
      for dep in ${depends[@]} ${makedepends[@]}; do
        # remove versioning
        dep=${dep%%<*}; dep=${dep%%>*}; dep=${dep%%=*}

        # check if dep is satisfied
        pacman -T $dep &>/dev/null && continue

        # check if dep is available in repo (anything not is
        # assumed to be available via AUR)
        if pacman -Sqs ^$dep$ &>/dev/null; then
          warn "$dep required by $name. this may be installed via pacman."
        else
          grep -q "^$dep\ .$" "$WD/deps.lst" || echo "$dep 1" >> "$WD/deps.lst"
        fi

      done
    done

    # if we found no more deps this round, we can stop
    [ $(wc -l < "$WD/deps.lst") -eq $N ] && break
  done

  # remove these PKGBUILDs as they'll cause problems later on
  find "$WD" -depth -mindepth 1 -type d -exec rm -r {} \;
}

# }}}

# get targets {{{
#
# accepts no args
#
# calls dep_check, which sets target.lst
#
###
get_targets() {
  [ "${#args[@]}" -eq 0 ] && errorout 1 'no targets specified'

  touch "$WD/deps.lst"
  touch "$WD/targets.lst"

  # reverse the main args b/c deps.lst is parsed bottom up
  for ((i=${#args[@]}; i>0; i--)); do 
    echo "${args[$i-1]} 0" >> "$WD/deps.lst"
  done

  # resolve deps here
  [ $DEPS -eq 1 ] && dep_check

  pacman -Qm > "$WD/installed.lst"

  echo 'searching AUR...'

  # parse deps list bottom up
  while read name DEP; do
    if echo " $IGNORES " | grep -Fq " $name "; then
      warn "$name found in \$IGNORES, skipping..."
      continue
    fi

    curl -s "http://aur.archlinux.org/rpc.php?type=search&arg=${name}" | sed 's/{/\n/g' | grep -Fm 1 "\"$name\"" > "$WD/results.lst"

    PACK="$(awk -F ',' '{print $2}' "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-2)}')"
    VERS="$(awk -F ',' '{print $3}' "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-2)}')"
    URL="http://aur.archlinux.org$(awk -F ',' '{print $8}' "$WD/results.lst" | awk -F ':' '{print substr($2,2,length($2)-2)}' | sed 's/\\\//\//g')"

    [ -z "$PACK" ] && errorout 1 "'$name': package not found in AUR."
    
    echo $PACK $VERS $URL $DEP >> "$WD/targets.lst"
    grep -Fqx $PACK\ $VERS "$WD/installed.lst" && warn "$PACK-$VERS is up to date -- reinstalling"
  done < <(tac "$WD/deps.lst")

  # print it like pacman
  N=$(wc -l < "$WD/targets.lst")
  echo -e "\n\e${colorY}Targets ($N): \e[0m$(awk '{print $1 "-" $2}' "$WD/targets.lst" | xargs)\n"

  prompt 'Proceed with installation' || clean_exit 1

  # start the download
  downloadit
}

# }}}

# download {{{
#
# accepts no args
#
# downloads/extracts everything in targets.lst
#   will only ever be called by get_targets()
#
###
downloadit() {
  display 'Retrieving source files from AUR...'
  for PACK in $(awk '{print $1}' "$WD/targets.lst"); do
    mkdir "$WD/$PACK"
    URL="$(awk "/^$PACK\ /"'{print $3}' "$WD/targets.lst")"
    wget -O "$WD/$PACK/$PACK.tar.gz" "$URL"

    # some packages report a bad URL in JSON
    if ! file "$WD/$PACK/$PACK.tar.gz" | grep -Fq gzip; then
      echo " $PACK: not a valid tarball, trying alternate url..."
      wget -O "$WD/$PACK/$PACK.tar.gz" "http://aur.archlinux.org/packages/$PACK/$PACK.tar.gz" || errorout 1 "$PACK: failed downloading tarball."
    fi

    # if 'download' then save the tarball
    [ "$MODE" = 'download' ] && cp "$WD/$PACK/$PACK.tar.gz" ./
  done
}

# }}}

# build {{{
#
# accepts one arg
# 
# cd's to the dir and runs makepkg
#   will only ever be called by installit()
#
###
buildit() {
  local PACK="$1"

  pushd "$WD/$PACK" &>/dev/null || errorout 2 "$WD/$PACK: failed to change directory"
  tar xvzf $PACK.tar.gz &>/dev/null || errorout 2 "$PACK.tar.gz: failed unpacking the tarball."

  pkgbuild="$(find "$WD/$PACK" -name 'PKGBUILD' -print -quit)"
  [ -z "$pkgbuild" ] && errorout 2 "$PACK: no PKGBUILD found."

  if [ $EDIT -eq 1 ]; then
    $EDITOR "$pkgbuild"
    prompt 'Continue building package' || clean_exit 1
  fi

  pkgdir="$(dirname "$pkgbuild")"
  pushd "$pkgdir" &>/dev/null || errorout 2 "$pkgdir: failed to change directory."

  if [ $DEPS -eq 1 ]; then
    # let pacman check deps
    PKGDEST="$PWD" makepkg --noconfirm -s $MAKEPKG_OPTS || errorout 2 "$PACK: failed making the package."
  else
    # no depchecking for you!
    PKGDEST="$PWD" makepkg --noconfirm -d $MAKEPKG_OPTS || errorout 2 "$PACK: failed making the package."
  fi

  popd &>/dev/null
}

# }}}

# install {{{
#
# accepts no args
#
# calls build, stops depending on MODE, and 
# installs/saves the package
#
###
installit() {
  local PACK DEP OPTS PKG

  # add sudo if we're not root
  [ $(id -u) -ne 0 ] && PACMAN="sudo $PACMAN"

  while read PACK DEP; do
    buildit $PACK

    PKG=$(find "$WD/$PACK" -name "$PACK-*pkg.tar.gz")
    
    # optionally install
    if [ "$MODE" = 'install' ]; then
      # install deps correctly
      [ $DEP -eq 1 ] && OPTS='-U --asdeps' || OPTS='-U'

      $PACMAN $OPTS "$PKG" || errorout 2 "$PACK: failed installing package."
    fi

    cp "$PKG" "$PD/" || errorout 2 "$PACK: failed saving package."
  done < <(awk '{print $1, $4}' "$WD/targets.lst")
}

# }}}

# parse options {{{
#
# parses all args
#
# set constants and leaves everything else in ${args[@]}
#
###
parse_options() {
  OPTS=$(getopt -q -o hvIsqpuUdbieD --long help,version,info,search,quiet,print,upgrade,devel,download,build,install,edit,nodeps -- "$@")

  [ $? -ne 0 ] && message 
  eval set -- "$OPTS"

  doupgrade=0
  dodevel=0

  while true; do
    case $1 in
      -h|--help)     message         ;;
      -v|--version)  version_info    ;;
      -u|--upgrade)  doupgrade=1     ;;
      -U|--devel)    dodevel=1       ;;
      -I|--info)     MODE='info'     ;;
      -s|--search)   MODE='search'   ;;
      -q|--quiet)    MODE='quiet'    ;;
      -p|--print)    MODE='print'    ;;
      -d|--download) MODE='download' ;;
      -b|--build)    MODE='build'    ;;
      -i|--install)  MODE='install'  ;;
      -e|--edit)     EDIT=1          ;;
      -D|--nodeps)   DEPS=0          ;;
      --)            shift; break    ;;
      *)             message         ;;
    esac
    shift
  done

  args=( "$@" )
}

# }}}

# main {{{
#
# accepts no args
#
# runs the script on ${args[@]} using all constants
# in it's operation
#
###
main() {
  # no dep checking if we're not installing
  [ "$MODE" != 'install' ] && DEPS=0

  if [ $doupgrade -eq 1 ]; then
    upgrade
  elif [ $dodevel -eq 1 ]; then
    devel
  else
    case $MODE in
      info|search|quiet) search "${args[*]}"              ;;
      build|install)     get_targets; installit           ;;
      download)          get_targets;                     ;;
      print)             printpbuild ${args[@]}           ;;
      *)                 errorout 1 "invalid mode: $MODE" ;;
    esac
  fi

}

# }}}

# }}}

#### Run it #### {{{

set_title
create_config 
make_clean 
parse_options "$@"
main
clean_exit

# }}}

# vim:foldmethod=marker foldmarker={{{,}}}
