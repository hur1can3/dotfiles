#!/bin/bash
#
# pbrisbin 2009, 2010
#
# a work in progress
#
# prune a dir of packages back to only N versions
# from installed
#
###

safety=true   # just make a list
#safety=false # actually prune packages

message() {
  echo "pacprune [-n number] [-d directory]"
  echo
  echo "  defaults to 3 and ./"
  echo
  exit 1
}

logger() { echo "$(date +'[ %d %b %Y %H:%M ]') :: $*" | tee -a "$log"; }

errorout() { logger "ERROR: $*"; exit 1; }

rel2abs() {
  local file="$(basename "$1")"
  local dir="$(dirname "$1")"

  pushd "${dir:-./}" &>/dev/null || errorout 'failed to change directory'
  dir="$PWD"

  popd &>/dev/null

  echo "$dir/$file"
}

# get commandline switches
parse_options() {
  while [ -n "$1" ]; do
    case "$1" in
      -n) shift; N="$1"  ;;
      -d) shift; prune_dir="$1" ;;
      *)  message        ;;
    esac
    shift
  done

  # check for valid input
  [ -z "${N//[0-9]/}" ] || errorout "Invalid number: $N" # must be numeric
  [ -d "$prune_dir" ] || errorout "Invalid directory: $prune_dir"      # must exist

  # set an absolute path
  prune_dir="$(rel2abs "$prune_dir")"
}

# accepts a .pkg.tar.gz
# returns "name version path"
get_pkg_info() {
  local package="$1"

  gunzip < "$package" | bsdtar -qxf - .PKGINFO || errorout "failed to extract info for $package"

  name="$(awk '/^pkgname/ {print $3}' .PKGINFO)"
  vers="$(awk '/^pkgver/ {print $3}' .PKGINFO)"

  echo $name $vers $package
}

# gets info for all packages
# sets up all.lst
create_all_list() {
  local LC_ALL="C"

  touch "$dir/all.lst"
  logger "gathering package info..."

  pushd "$dir" &>/dev/null || errorout "failed to change directory"

  find "$prune_dir" -maxdepth 1 -type f -name '*.pkg.tar.gz' | sort -r | while read package; do
    logger "reading package $package"

    get_pkg_info "$package" >> "$dir/all.lst"
  done

  popd &>/dev/null || errorout "failed to change directory"
}

# queries pacman
# sets up discard.lst
create_discard_list() {
  # copy files into a discard list
  awk '{print $3}' "$dir/all.lst" > "$dir/discard.lst"

  # weed out the one's to save
  pacman -Qq | while read pack; do
    grep -m $N ^$pack\  "$dir/all.lst" | awk '{print $3}' | while read file; do
      logger "marking $file for discarding"
      sed -i "/${file//\//\\/}/d" "$dir/discard.lst"
    done
  done
}

# checks if safety is on
check_safety() {
  if $safety; then
    logger 
    logger "the safety is on."
    logger 
    logger "$dir/discard.lst contains packages that would've"
    logger "been pruned had the safety been off."
    logger
    exit 0
  fi
}

# uses discard.lst to remove pkgs
prune_pkgs() {
  logger 'pruning packages...'
  mkdir ./garbage || errorout 'unable to make garbage directory'

  while read package; do
    logger "moving $package to ./garbage..."

    if [ ! -w "$prune_dir" ]; then
      sudo mv "$package" ./garbage/ || errorout "failed moving $package to ./garbage"
    else
      mv "$package" ./garbage/ || errorout "failed moving $package to ./garbage"
    fi

  done < "$dir/discard.lst"

  logger 'done'
}

# log
log="$HOME/.logs/pacprune.log"

# set defaults
dir='/tmp/pruned'
prune_dir='./'
N=3

[ $(id -u) -eq 0 ] && errorout "don't run me as root, sudo will be added if needed"

# set up
rm -rf $dir; mkdir -p $dir

# run it
parse_options "$@"
create_all_list
create_discard_list
check_safety
prune_pkgs

# remove it all clear
[ $? -eq 0 ] && rm -r "$dir"
